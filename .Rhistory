usethis::create_from_github("RanLIUaca/demotif")
usethis::create_from_github("RanLIUaca/demotif", fork = FALSE)
a = matrix(1, nrow = 3,ncol=3)
length(a)
sum(a==b)
a = matrix(1, nrow = 3,ncol=3)
b = matrix(1, nrow = 3,ncol=3)
length(a)
sum(a==b)
#### setting for c2 delta2
n = 2000
c2 = c(.3,.5,.7)
del2 = c(.05,.1,.15,.2,.25)
# c2 = c(.1,.2,.3)
# del2 = c(.001,.002,.003,.004,.005)
til_h = matrix(nrow = length(c2),ncol = length(del2))
for (i in 1:3) {
for (j in 1:5) {
til_h[i,j] = floor(c2[i] * n^(2/3+del2[j]))+1
}
}
til_h
#### setting for c2 delta2
n = 2000
c2 = c(.2,.4,.6)
del2 = c(.05,.1,.15,.2,.25)
# c2 = c(.1,.2,.3)
# del2 = c(.001,.002,.003,.004,.005)
til_h = matrix(nrow = length(c2),ncol = length(del2))
for (i in 1:3) {
for (j in 1:5) {
til_h[i,j] = floor(c2[i] * n^(2/3+del2[j]))+1
}
}
til_h
#### setting for c2 delta2
n = 2000
c2 = c(.1,.3,.5)
del2 = c(.05,.1,.15,.2,.25)
# c2 = c(.1,.2,.3)
# del2 = c(.001,.002,.003,.004,.005)
til_h = matrix(nrow = length(c2),ncol = length(del2))
for (i in 1:3) {
for (j in 1:5) {
til_h[i,j] = floor(c2[i] * n^(2/3+del2[j]))+1
}
}
til_h
n = 2000
c2 = c(.1,.3,.5)
del2 = c(.01,.05,.1,.15)
# c2 = c(.1,.2,.3)
# del2 = c(.001,.002,.003,.004,.005)
til_h = matrix(nrow = length(c2),ncol = length(del2))
for (i in 1:3) {
for (j in 1:5) {
til_h[i,j] = floor(c2[i] * n^(2/3+del2[j]))+1
}
}
#### setting for c2 delta2
n = 2000
c2 = c(.1,.3,.5)
del2 = c(.01,.05,.1,.15)
til_h = matrix(nrow = length(c2),ncol = length(del2))
til_h
til_h = matrix(nrow = length(c2),ncol = length(del2))
for (i in 1:length(c2)) {
for (j in 1:length(del2)) {
til_h[i,j] = floor(c2[i] * n^(2/3+del2[j]))+1
}
}
til_h
n = 2000
c2 = c(.1,.3,.5)
del2 = c(.01,.05,.1,.15,.2)
# c2 = c(.1,.2,.3)
# del2 = c(.001,.002,.003,.004,.005)
til_h = matrix(nrow = length(c2),ncol = length(del2))
for (i in 1:length(c2)) {
for (j in 1:length(del2)) {
til_h[i,j] = floor(c2[i] * n^(2/3+del2[j]))+1
}
}
til_h
#### setting for c2 delta2
n = 2000
c2 = c(.1,.3,.5)
del2 = c(.01,.05,.1)
# c2 = c(.1,.2,.3)
# del2 = c(.001,.002,.003,.004,.005)
til_h = matrix(nrow = length(c2),ncol = length(del2))
for (i in 1:length(c2)) {
for (j in 1:length(del2)) {
til_h[i,j] = floor(c2[i] * n^(2/3+del2[j]))+1
}
}
til_h
#### setting for c2 delta2
n = 2000
c2 = c(.1,.3,.5,.7)
del2 = c(.01,.05,.1)
# c2 = c(.1,.2,.3)
# del2 = c(.001,.002,.003,.004,.005)
til_h = matrix(nrow = length(c2),ncol = length(del2))
for (i in 1:length(c2)) {
for (j in 1:length(del2)) {
til_h[i,j] = floor(c2[i] * n^(2/3+del2[j]))+1
}
}
til_h
#### setting for c2 delta2
n = 2000
c2 = c(.1,.3,.5,.7)
del2 = c(.01,.05,.1,.15)
# c2 = c(.1,.2,.3)
# del2 = c(.001,.002,.003,.004,.005)
til_h = matrix(nrow = length(c2),ncol = length(del2))
for (i in 1:length(c2)) {
for (j in 1:length(del2)) {
til_h[i,j] = floor(c2[i] * n^(2/3+del2[j]))+1
}
}
til_h
n = 2000
c2 = c(.1,.3,.5,.7)
del2 = c(.01,.05,.1,.15,.2)
# c2 = c(.1,.2,.3)
# del2 = c(.001,.002,.003,.004,.005)
til_h = matrix(nrow = length(c2),ncol = length(del2))
for (i in 1:length(c2)) {
for (j in 1:length(del2)) {
til_h[i,j] = floor(c2[i] * n^(2/3+del2[j]))+1
}
}
til_h
#### setting for c2 delta2
n = 2000
c2 = c(.1,.3,.5)
del2 = c(.01,.05,.1,.15)
# c2 = c(.1,.2,.3)
# del2 = c(.001,.002,.003,.004,.005)
til_h = matrix(nrow = length(c2),ncol = length(del2))
for (i in 1:length(c2)) {
for (j in 1:length(del2)) {
til_h[i,j] = floor(c2[i] * n^(2/3+del2[j]))+1
}
}
til_h
n = 2000
c2 = c(.1,.5,.7)
del2 = c(.01,.05,.1,.15)
# c2 = c(.1,.2,.3)
# del2 = c(.001,.002,.003,.004,.005)
til_h = matrix(nrow = length(c2),ncol = length(del2))
for (i in 1:length(c2)) {
for (j in 1:length(del2)) {
til_h[i,j] = floor(c2[i] * n^(2/3+del2[j]))+1
}
}
til_h
#### setting for c2 delta2
n = 2000
c2 = c(.1,.3,.5)
del2 = c(.01,.05,.1,.15)
# c2 = c(.1,.2,.3)
# del2 = c(.001,.002,.003,.004,.005)
til_h = matrix(nrow = length(c2),ncol = length(del2))
for (i in 1:length(c2)) {
for (j in 1:length(del2)) {
til_h[i,j] = floor(c2[i] * n^(2/3+del2[j]))+1
}
}
til_h
#### setting for c2 delta2
n = 2000
c2 = c(.1,.3,.5)
del2 = c(.01,.03,.05,.07,.1)
# c2 = c(.1,.2,.3)
# del2 = c(.001,.002,.003,.004,.005)
til_h = matrix(nrow = length(c2),ncol = length(del2))
for (i in 1:length(c2)) {
for (j in 1:length(del2)) {
til_h[i,j] = floor(c2[i] * n^(2/3+del2[j]))+1
}
}
til_h
h = c(floor(2 * n^(.5))+1)
h
h = c(floor(2 * n^(.3))+1)
h
h = c(floor(2 * n^(.7))+1)
h
h = c(floor(7 * n^(.5))+1)
h
h = c(floor(5 * n^(.5))+1)
h
h = c(floor(7 * n^(.5))+1)
h
h = c(floor(2 * n^(.5))+1)
h
h = c(floor(5 * n^(.5))+1)
h
#### setting for c2 delta2
n = 2000
c2 = c(.1,.3,.5)
del2 = c(.01,.03,.05,.07,.1)
# c2 = c(.1,.2,.3)
# del2 = c(.001,.002,.003,.004,.005)
til_h = matrix(nrow = length(c2),ncol = length(del2))
for (i in 1:length(c2)) {
for (j in 1:length(del2)) {
til_h[i,j] = floor(c2[i] * n^(2/3+del2[j]))+1
}
}
til_h
rm(list=ls())
# setwd('X:/LR_flat_motif_gap/real_data/code')
setwd('/storage01/users/z120688/LR_flat_motif_gap/real_data/code/')
# 你需要告诉 R 当前在哪个目录操作（即你的包目录）
setwd("C:/Users/10343/OneDrive - The Chinese University of Hong Kong/Research/LR_flat_motif_gap/GAMMAmotif")
devtools::document()
devtools::install()
# Load the GAMMAmotif package (contains the main inference function)
library(GAMMAmotif)
# Load required dependencies
library(MCMCpack)
library(stringr)
library(MASS)
library(ggseqlogo)
library(ggplot2)
# Load the built-in example dataset
# The dataset contains 3 motifs, each of length 4, embedded in the sequences
data(sample_data)
# Preview the first few rows of the data
head(sample_data)
# Number of sequences
total_n = length(sample_data[,1])
# Define the alphabet (dictionary) used in the sequences
# Here we use the 20 amino acids for protein sequences
dict = 'ACDEFGHIKLMNPQRSTVWY'
# Split the string into individual characters
tmp_index = 1:str_length(dict)
dict = str_sub(dict, tmp_index, tmp_index)
# Create a mapping between characters and numeric indices
digit_dict = as.character(1:length(dict))
names(digit_dict) = dict
names(dict) = digit_dict
# Get dictionary length
len_dict = length(dict)
# -------------------------------
# Set inference parameters
# -------------------------------
num_motif = 3                  # Number of motifs to discover
Motif_length = rep(4, 3)       # Each motif is 4 characters long
sum_N = 20                     # Total number of MCMC iterations
burnin = 10                    # Burn-in period (used to discard early samples)
mh_step_w = 10                 # Frequency of Metropolis-Hastings "shift" proposals
# -------------------------------
# Run Bayesian motif inference
# -------------------------------
# GAMMA_FUN performs MCMC-based inference for motif PWM, positions (A),
# motif type assignments (W), and optional gap parameters (lambda)
Res = GAMMA_FUN(
Data = sample_data,          # Input data: a data frame with 'seq' and 'W_obs'
dict = dict,                 # Alphabet used in sequences
num_motif = num_motif,       # Number of motifs to infer
Motif_length = Motif_length, # Lengths of each motif
sum_N = sum_N,               # Total MCMC iterations
burnin = burnin,             # Number of burn-in iterations
mh_step_w = mh_step_w        # Interval for MH shift proposals
)
# The result 'Res' contains:
# Res$Theta_0   - MAP estimate of the background distribution
# Res$Theta     - List of MAP motif PWMs (probability matrices)
# Res$W         - MAP motif type assignments for each sequence
# Res$A         - MAP motif positions in each sequence
# Res$plot      - A list of ggplot2 objects (log-likelihood trace and logo plots)
# Use posterior samples to estimate motif type and position for each sequence
pred_frame = pred_ana(
Data = sample_data,
theta_0_samp = Res$Theta_0,       # Background distribution
theta_samp = Res$Theta,           # Motif PWMs
Motif_length = Motif_length,      # Motif lengths
burnin = burnin,                  # Burn-in period
sum_N = sum_N                     # Total number of samples
)
# View predicted motif type and position
print(pred_frame$est_W)   # Predicted motif class (1 to num_motif, or background)
print(pred_frame$est_A)   # Predicted motif location(s) within each sequence
